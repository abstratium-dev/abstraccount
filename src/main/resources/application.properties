# don't use dev services, use a real database
quarkus.devservices.enabled=false

quarkus.datasource.db-kind=mysql
%dev.quarkus.datasource.username=TODO
%dev.quarkus.datasource.password=secret
%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:41040/abstracore

# E2E Testing Profile - Uses H2 in-memory database
%e2e.quarkus.datasource.db-kind=h2
%e2e.quarkus.datasource.jdbc.url=jdbc:h2:mem:e2e;DB_CLOSE_DELAY=-1
%e2e.quarkus.datasource.username=sa
%e2e.quarkus.datasource.password=

quarkus.hibernate-orm.schema-management.strategy=none
%dev.quarkus.hibernate-orm.log.sql=false

quarkus.flyway.migrate-at-start=true

quarkus.log.console.format=%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) [skey:%X{abstratiumkey}] %s%e%n
quarkus.log.level=INFO
%dev.quarkus.log.category."dev.abstratium".level=DEBUG
%dev.quarkus.log.category."io.quarkus.quinoa".level=DEBUG
#%dev.quarkus.log.category."io.quarkus.oidc".level=DEBUG
#%dev.quarkus.log.category."io.quarkus.oidc.runtime".level=DEBUG

# because we are behind proxy. see https://quarkus.io/guides/http-reference#reverse-proxy
quarkus.http.proxy.allow-forwarded=true
quarkus.http.proxy.proxy-address-forwarding=true
quarkus.http.proxy.enable-forwarded-host=true
quarkus.http.proxy.enable-forwarded-prefix=true

# JWT Verification Configuration
# Public key for verifying JWT signatures (extracted from private key using extract-public-key.sh)
# TODO is this required?
%dev.mp.jwt.verify.publickey=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwbzPq4iKBGsSLS7TlNKK95ENz/Tpu6TeDZjN9jjTCcR0p+p/hqYp3hBngnchXBOTpERdGugawwDVw1H4RkHHJzerugWpSHmxdKVQacq2vovVnKW29XYsWYJunIETptWQ6knyBp8ePD7DKhzPxBOiyx3ogfFf23ZndNXokYPywKfKuwWSRgZQ2VDZnnT/25HFPLMwU/F+mQ+G7YiEw2WSsS1rYGbBCZhdLbfdIA0gcuaVP3sMFK0zGgk49nkIEOQH3nzGerSU+qYWARBclj0xJJEvrpSXLdMbd6z63pHLHngHTOtRXbWjnUq/k71m1Uae7OakqG0/amgjOfuG5z7/WwIDAQAB
%test.mp.jwt.verify.publickey=${%dev.mp.jwt.verify.publickey}
%e2e.mp.jwt.verify.publickey=${%dev.mp.jwt.verify.publickey}
%prod.mp.jwt.verify.publickey=SET-USING-ENV-VAR

# Map the 'groups' claim in JWT to roles for @RolesAllowed
smallrye.jwt.path.groups=groups
smallrye.jwt.claims.groups=groups

# ============================================================================
# OIDC Configuration - BFF tenant for /api/* endpoints only
# ============================================================================
# Use a named tenant that only applies to /api/* paths
# This prevents OIDC from intercepting /public/*

# BFF tenant configuration
quarkus.oidc.tenant-enabled=true
quarkus.oidc.tenant-paths=/api/*
quarkus.oidc.auth-server-url=https://auth.abstratium.dev

# Manual endpoint configuration
# TODO required?
# quarkus.oidc.authorization-path=/oauth2/authorize
# quarkus.oidc.token-path=/oauth2/token
# quarkus.oidc.jwks-path=/.well-known/jwks.json
# quarkus.oidc.end-session-path=/api/auth/logout

# Client credentials
quarkus.oidc.client-id=abstratium-TODO
quarkus.oidc.credentials.secret=${ABSTRATIUM_CLIENT_SECRET:dev-secret-CHANGE-IN-PROD}

# Token endpoint authentication - Basic Auth is now supported by TokenResource
# No additional config needed - Quarkus OIDC uses Basic Auth by default

# Application type: web-app (authorization code flow)
quarkus.oidc.application-type=web-app

# PKCE configuration
quarkus.oidc.authentication.pkce-required=true

# Scopes to request (openid is automatically added by Quarkus OIDC)
quarkus.oidc.authentication.scopes=profile,email

# TODO do we need these?
# Redirect paths - must be under /api to match cookie-path
# quarkus.oidc.authentication.redirect-path=/api/auth/callback
# quarkus.oidc.authentication.restore-path-after-redirect=true

# Force HTTPS scheme in redirect_uri when behind SSL-terminating reverse proxy
# This ensures redirect_uri uses https:// even when the app receives http:// requests
%dev.quarkus.oidc.authentication.force-redirect-https-scheme=false
%test.quarkus.oidc.authentication.force-redirect-https-scheme=false
%e2e.quarkus.oidc.authentication.force-redirect-https-scheme=false
%prod.quarkus.oidc.authentication.force-redirect-https-scheme=true

# Cookie configuration (HTTP-only, secure, encrypted) - scoped to BFF tenant
quarkus.oidc.token-state-manager.strategy=id-refresh-tokens
quarkus.oidc.token-state-manager.split-tokens=true
quarkus.oidc.token-state-manager.encryption-required=true
quarkus.oidc.token-state-manager.encryption-secret=${COOKIE_ENCRYPTION_SECRET:dev-encryption-key-must-be-at-least-32-chars-long}

# Session timeout - use centralized config (PT15M = 15 minutes = 900 seconds)
quarkus.oidc.authentication.session-age-extension=PT900S

# Cookie settings - CRITICAL: scope to /api to prevent interference with /oauth2
quarkus.oidc.authentication.cookie-path=/api
quarkus.oidc.authentication.cookie-same-site=strict

# Logout configuration
quarkus.oidc.logout.path=/api/auth/logout
quarkus.oidc.logout.post-logout-path=/

# Error handling configuration
quarkus.oidc.authentication.error-path=/api/auth/error

# Forward these paths to Quarkus backend instead of Angular dev server
# TODO why do i need to keep this list sync with proxy.conf.json?
quarkus.quinoa.ignored-path-prefixes=/oauth2,/.well-known,/api

# Quinoa configuration - Angular is in src/main/webui and outputs to dist/TODO/browser
quarkus.quinoa.ui-dir=src/main/webui
quarkus.quinoa.build-dir=dist/TODO/browser
quarkus.quinoa.enable-spa-routing=true
quarkus.quinoa.package-manager-install=true
quarkus.quinoa.package-manager-install.node-version=24.11.1

# E2E Profile - Ensure Quinoa builds Angular app for e2e tests
%e2e.quarkus.quinoa.package-manager-install=true

# ============================================================================
# CSRF Protection - Custom Implementation
# ============================================================================
# 
# WHY CUSTOM IMPLEMENTATION:
# The quarkus-rest-csrf extension applies globally to ALL POST/PUT/DELETE/PATCH requests,
# with no way to exclude specific paths. This is problematic because:
# 1. OAuth2 login endpoints (/oauth2/authorize/authenticate) already have CSRF protection
#    via the request_id parameter (server-side validation)
# 2. We cannot exclude /oauth2/* paths from quarkus-rest-csrf verification
# 3. Enabling quarkus-rest-csrf blocks legitimate OAuth2 login requests
#
# We want to use HMAC and that requires that the session be known. But it isn't known until after signing in.
#
# CUSTOM IMPLEMENTATION (ApiCsrfFilter + ApiCsrfTokenGenerator):
# - Only applies to /api/* endpoints (OAuth2 endpoints use request_id)
# - Implements Signed Double Submit Cookie pattern with HMAC
# - Token format: base64(hmac).base64(random)
# - HMAC binds token to user's session (principal name)
# - Cookie name: XSRF-TOKEN (matches Angular default)
# - Header name: X-XSRF-TOKEN (matches Angular default)
# - Cookie max-age: Reuses quarkus.oidc.authentication.session-age-extension
# - HttpOnly: false (so Angular can read the cookie)
# - SameSite: Strict
# 
# SECURITY STATUS:
# - OAuth2 endpoints: Protected by request_id parameter (server-side validation)
# - /api/* endpoints: Protected by HMAC-signed CSRF tokens
# - Defense in depth: CORS, CSP, SameSite cookies, OIDC authentication

# Enable/disable CSRF protection
csrf.protection.enabled=true
%test.csrf.protection.enabled=false
%e2e.csrf.protection.enabled=true

# HMAC signature key for CSRF tokens (min 32 characters)
# Generate with: openssl rand -base64 64
csrf.token.signature.key=${CSRF_TOKEN_SIGNATURE_KEY:dev-csrf-key-CHANGE-IN-PRODUCTION-must-be-at-least-32-characters-long-for-security}

# ============================================================================
# CORS Configuration
# ============================================================================

# Enable CORS filter
quarkus.http.cors.enabled=true

# Allowed origins - restrict to your domains
%dev.quarkus.http.cors.origins=http://localhost:4200,http://localhost:8080
%test.quarkus.http.cors.origins=http://localhost:8080
%e2e.quarkus.http.cors.origins=http://localhost:8080
%prod.quarkus.http.cors.origins=https://TODO.abstratium.dev,TODO

# Allowed methods
quarkus.http.cors.methods=GET,POST,PUT,DELETE,PATCH,OPTIONS

# Allowed headers - include CSRF header
quarkus.http.cors.headers=Content-Type,Authorization,X-XSRF-TOKEN

# Expose headers
quarkus.http.cors.exposed-headers=Content-Disposition

# Allow credentials (required for cookies)
quarkus.http.cors.access-control-allow-credentials=true

# Preflight cache duration
quarkus.http.cors.access-control-max-age=24H

# Security Headers Configuration
# Content Security Policy - Protects against XSS, clickjacking, and code injection
security.csp.enabled=true
security.csp.policy=default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' https://abstratium.dev; font-src 'self'; connect-src 'self'; frame-ancestors 'none'; base-uri 'self'; form-action 'self'

# HSTS (HTTP Strict Transport Security) - Forces HTTPS
# Disabled by default (dev/test/e2e use HTTP), enabled in production
security.hsts.enabled=false
security.hsts.max-age=31536000
security.hsts.include-subdomains=true
security.hsts.preload=true

# Enable HSTS in production (requires HTTPS)
%prod.security.hsts.enabled=true

# Disable rate limiting in test profile to avoid interfering with tests
%test.rate-limit.enabled=false
%e2e.rate-limit.enabled=false

# Production: Consider stricter limits
# %prod.rate-limit.oauth.max-requests=5
# %prod.rate-limit.oauth.window-seconds=60
# %prod.rate-limit.oauth.ban-duration-seconds=600

# https://quarkus.io/guides/management-interface-reference
quarkus.management.enabled=true
quarkus.management.host=localhost
quarkus.management.port=9002
quarkus.management.root-path=/m

quarkus.info.enabled=true
quarkus.info.build.enabled=true
quarkus.info.git.enabled=true
quarkus.info.java.enabled=true
quarkus.info.os.enabled=true

# Add custom properties to the build section
quarkus.info.build.app-name=TODO

# Build version - injected by Maven during build
build.version=@build.version@

# TODO still required? since it is in the build script
# Native build configuration for CPU compatibility
# Use -march=compatibility to support older CPUs without AVX/AVX2
quarkus.native.additional-build-args=-march=compatibility,-H:+ReportExceptionStackTraces,--initialize-at-run-time=org.eclipse.angus.mail.util.MailLogger
# This will:
# -march=compatibility: Generate code compatible with older x86-64 CPUs (baseline x86-64 instruction set)
# Keep your existing build arguments for exception traces and runtime initialization